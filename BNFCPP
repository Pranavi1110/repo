#include <bits/stdc++.h>
using namespace std;

struct Node {
    string val;
    Node* left;
    Node* right;
    Node(string v) : val(v), left(NULL), right(NULL) {}
};

// --- Expression Parser for AST ---
string expr;
int pos = 0;

Node* parseExpr(); 
Node* parseTerm(); 
Node* parseFactor();

Node* parseFactor() {
    if (expr[pos] == '(') {
        pos++;
        Node* node = parseExpr();
        pos++; // skip ')'
        return node;
    } else {
        string num = "";
        while (pos < expr.size() && isalnum(expr[pos]))
            num += expr[pos++];
        return new Node(num);
    }
}

Node* parseTerm() {
    Node* node = parseFactor();
    while (pos < expr.size() && (expr[pos] == '*' || expr[pos] == '/')) {
        char op = expr[pos++];
        Node* right = parseFactor();
        Node* parent = new Node(string(1, op));
        parent->left = node;
        parent->right = right;
        node = parent;
    }
    return node;
}

Node* parseExpr() {
    Node* node = parseTerm();
    while (pos < expr.size() && (expr[pos] == '+' || expr[pos] == '-')) {
        char op = expr[pos++];
        Node* right = parseTerm();
        Node* parent = new Node(string(1, op));
        parent->left = node;
        parent->right = right;
        node = parent;
    }
    return node;
}

// ---------- HORIZONTAL TREE PRINTING ----------
vector<string> buildTree(Node* root) {
    if (!root) return {" "};

    string val = root->val;

    vector<string> left = buildTree(root->left);
    vector<string> right = buildTree(root->right);

    int lw = left[0].size();
    int rw = right[0].size();
    int rootWidth = val.size();

    // center root
    string rootLine = string(lw, ' ') + val + string(rw, ' ');

    // branches
    string branchLine(lw + rootWidth + rw, ' ');

    if (root->left)  branchLine[lw - 1] = '/';
    if (root->right) branchLine[lw + rootWidth] = '\\';

    vector<string> result;
    result.push_back(rootLine);
    result.push_back(branchLine);

    int maxLines = max(left.size(), right.size());
    for (int i = 0; i < maxLines; i++) {
        string L = (i < left.size() ? left[i] : string(lw, ' '));
        string R = (i < right.size() ? right[i] : string(rw, ' '));
        result.push_back(L + string(rootWidth, ' ') + R);
    }
    return result;
}

void printHorizontalTree(Node* root) {
    vector<string> lines = buildTree(root);
    for (string &line : lines) cout << line << "\n";
}
// ------------------------------------------------

int main() {
    cout << "Enter your BNF grammar (end with an empty line):\n";
    string line;
    map<string,string> rules;

    while (true) {
        getline(cin, line);
        if (line.empty()) break;

        size_t pos = line.find("::=");
        if (pos == string::npos) pos = line.find("->");

        string lhs = line.substr(0, pos);
        string rhs = line.substr(pos + 3);
        rules[lhs] = rhs;
    }

    cout << "Converted YACC rules:\n";
    cout << "{";
    for (auto &r : rules) 
        cout << "'" << r.first << "': '" << r.second << "', ";
    cout << "}\n";

    while (true) {
        cout << "Enter expressions to parse (type 'exit' to quit):\n>>> ";
        getline(cin, expr);
        if (expr == "exit") break;

        expr.erase(remove(expr.begin(), expr.end(), ' '), expr.end());
        pos = 0;
        Node* root = parseExpr();

        cout << "\nAST (Horizontal Tree):\n";
        printHorizontalTree(root);
        cout << "\n";
    }
}



<expr> ::= <expr> + <term> | <expr> - <term> | <term> 
<term> ::= <term> * <factor> | <term> / <factor> | <factor> 
<factor> ::= ( <expr> ) | NUMBER
